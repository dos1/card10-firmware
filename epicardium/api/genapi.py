import argparse
import os
import re
import subprocess
import sys


MATCH_EXPANSION = re.compile(
    r"__GENERATE_API \$ __GEN_ID_(?P<id>\w+) \$ (?P<decl>.*?) \$",
    re.DOTALL | re.MULTILINE,
)

MATCH_DECLARATION = re.compile(
    r"^(?P<typename>.*?)\s*\((?P<args>.*)\)$",
    re.DOTALL,
)

MATCH_TYPENAME = re.compile(
    r"^(?P<type>(?:const )?(?:struct )?\w+(?:\s+|\*+))(?P<name>\w+)$",
)


def sizeof(args):
    """Return a string that describes the size of a list of arguments."""
    return " + ".join(a["sizeof"] for a in args) if args != [] else "0"


def bailout(message, *args, **kwargs):
    fmt = "\x1B[31;1mError\x1B[0m: {}"
    print(fmt.format(message.format(*args, **kwargs)), file=sys.stderr)
    sys.exit(1)


def parse_declarations(source):
    """Parse all declarations in the given source."""
    declarations = []
    for exp in MATCH_EXPANSION.finditer(source):
        id = exp.group("id")
        decl = MATCH_DECLARATION.match(exp.group("decl"))

        if decl is None:
            bailout("Error in declaration '{}'", exp.group("decl"))

        typename = MATCH_TYPENAME.match(decl.group("typename"))
        args = []
        args_str = decl.group("args")

        if typename is None:
            bailout("Error in declaration '{}'", exp.group("decl"))

        # Parse arguments
        for arg_str in map(str.strip, args_str.split(",")):
            if arg_str in ["void", ""]:
                continue

            arg = MATCH_TYPENAME.match(arg_str.strip())

            if arg is None:
                bailout("Failed to parse argument '{}'", arg_str.strip())

            args.append({
                "type": arg.group("type").strip(),
                "name": arg.group("name"),
                "sizeof": "sizeof({})".format(arg.group("type").strip()),
                "offset": sizeof(args),
            })

        declarations.append({
            "id": id,
            "return_type": typename.group("type").strip(),
            "name": typename.group("name"),
            "args": args,
            "args_str": args_str,
        })

    return declarations


def main():
    parser = argparse.ArgumentParser(
        description="Generate the API stubs from a header file."
    )
    parser.add_argument(
        "-H", "--header", required=True, help="The header to base the definitions on."
    )
    parser.add_argument(
        "-c", "--client", required=True, help="The output client-side c source file."
    )
    parser.add_argument(
        "-s", "--server", required=True, help="The output server-side c source file."
    )
    args = parser.parse_args()

    # Run the preprocessor on the header file to get the API definitions.
    #
    # For this, we first need a source to include the header which contains
    # an alternative definition of the `API` macro that marks definitions in
    # a way we can find later on.
    api_src = """\
#define API(id, def) __GENERATE_API $ __GEN_ID_##id $ def $
#include "{header}"
""".format(
        header=os.path.relpath(args.header)
    )

    # Evaluate the preprocessor
    source = subprocess.check_output(
        ["gcc", "-E", "-"], input=api_src.encode()
    ).decode()

    declarations = parse_declarations(source)
    fmt_header = {
        "header": os.path.basename(args.header)
    }

    # Generate Client {{{
    with open(args.client, "w") as f_client:
        tmp = """\
#include <stdio.h>

#include "{header}"
#include "api/caller.h"
"""
        f_client.write(tmp.format(**fmt_header))

        for decl in declarations:
            decl["total_size"] = sizeof(decl["args"])
            tmp = """\

/* Autogenerated stub for {id} */
{return_type} {name}({args_str})
{{
        const int size = {total_size};
        void*buffer;

        buffer = _api_call_start({id}, size);
        /* TODO: Check if buffer is not NULL */

"""
            f_client.write(tmp.format(**decl))

            for i, arg in enumerate(decl["args"]):
                tmp = """\
        *({type}*)(buffer + {offset}) = {name};
"""
                f_client.write(tmp.format(**arg))

            if decl["return_type"] == "void":
                # Don't return if return type is void
                tmp = """\

        _api_call_transact(buffer);
}}
"""
                f_client.write(tmp.format(**decl))
            else:
                tmp = """\

        return *({return_type}*)_api_call_transact(buffer);
}}
"""
                f_client.write(tmp.format(**decl))
    # END: Generate Client }}}

    # Generate Dispatcher {{{
    with open(args.server, "w") as f_dispatcher:
        tmp = """\
#include <stdio.h>
#include "{header}"

void __api_dispatch_call(uint32_t id, void*buffer)
{{
        switch (id) {{
"""
        f_dispatcher.write(tmp.format(**fmt_header))

        for decl in declarations:
            if decl["return_type"] == "void":
                tmp = """\
        case {id}:
                {name}("""
                f_dispatcher.write(tmp.format(**decl))
            else:
                tmp = """\
        case {id}:
                *(({return_type}*)buffer) = {name}("""
                f_dispatcher.write(tmp.format(**decl))

            for i, arg in enumerate(decl["args"]):
                arg["comma"] = "" if i == 0 else ","
                tmp = """{comma}
                        *({type}*)(buffer + {offset})"""
                f_dispatcher.write(tmp.format(**arg))

            tmp = """
                );
                break;
"""
            f_dispatcher.write(tmp.format(**decl))

        tmp = """\
        default:
                /* TODO: Better error handling */
                printf("Error: API function %lx is unknown!!\\n", id);
                break;
        }}
}}
"""
        f_dispatcher.write(tmp.format(**fmt_header))
    # END: Generate Dispatcher }}}


if __name__ == "__main__":
    main()
